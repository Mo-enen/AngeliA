using System.Collections;
using System.Collections.Generic;
using UnityEngine;


namespace AngeliaFramework {
	public static class CellRenderer {




		#region --- SUB ---



		public struct Cell {
			public int ID;
			public int X;
			public int Y;
			public int Width;
			public int Height;
			public int Rotation;
			public int PivotX;
			public int PivotY;
			public Color32 Color;
		}



		public class Layer {
			public Rect[] UVs;
			public Cell[] Cells;
			public Material Material;
			public int CellCount;
			public int UVCount;
			public int FocusedCell;
		}



		#endregion




		#region --- VAR ---


		// Api
		public static RectInt ViewRect { get; set; } = default;

		// Data
		private static Layer[] Layers = new Layer[0];
		private static Layer FocusedLayer = null;
		private static int FocusedLayerIndex = -1;
		private static Dictionary<int, (int sheet, int id)> SheetIDMap = new();


		#endregion




		#region --- MSG ---


		[RuntimeInitializeOnLoadMethod]
		private static void Init () {
			Camera.onPostRender -= OnPostRender;
			Camera.onPostRender += OnPostRender;
		}


		private static void OnPostRender (Camera camera) {

#if UNITY_EDITOR
			if (!UnityEditor.EditorApplication.isPlaying) {
				Camera.onPostRender -= OnPostRender;
				return;
			}
#endif

			// Ratio
			float ratio = (float)Screen.width / Screen.height;
			float maxRatio = (float)ViewRect.width / ViewRect.height;
			var rect = new Rect(0f, 0f, 1f, 1f);
			if (ratio > maxRatio) {
				rect = new Rect(0.5f - 0.5f * maxRatio / ratio, 0f, maxRatio / ratio, 1f);
			}
			if (camera.rect.NotAlmost(rect)) {
				camera.rect = rect;
			}

			// Size
			int width = Mathf.CeilToInt(ViewRect.height * Mathf.Min(
				(float)Screen.width / Screen.height,
				(float)ViewRect.width / ViewRect.height
			));
			int height = ViewRect.height;

			// Render
			GL.PushMatrix();
			GL.LoadProjectionMatrix(Matrix4x4.TRS(
				new Vector3(-1f, -1f, 0f),
				Quaternion.identity,
				new Vector3(2f / width, 2f / height, 1f)
			));

			try {
				int layerCount = Layers.Length;
				for (int index = 0; index < layerCount; index++) {
					DrawLayer(Layers[index]);
				}
			} catch (System.Exception ex) { Debug.LogException(ex); }

			GL.PopMatrix();
		}


		private static void DrawLayer (Layer layer) {

			var cells = layer.Cells;
			int cellCount = Mathf.Min(cells.Length, layer.FocusedCell);
			var uvs = layer.UVs;

			layer.Material.SetPass(0);
			GL.Begin(GL.QUADS);

			var a = Vector3.zero;
			var b = Vector3.zero;
			var c = Vector3.zero;
			var d = Vector3.zero;

			for (int i = 0; i < cellCount; i++) {

				var cell = cells[i];

				if (cell.ID < 0) { continue; }

				var uv = uvs[cell.ID];

				// Color
				GL.Color(cell.Color);

				// Position
				float pX = cell.Width * (cell.PivotX / 1000f);
				float pY = cell.Height * (cell.PivotY / 1000f);
				a.x = -pX;
				a.y = -pY;
				a.z = 0f;
				b.x = -pX;
				b.y = cell.Height - pY;
				b.z = 0f;
				c.x = cell.Width - pX;
				c.y = cell.Height - pY;
				c.z = 0f;
				d.x = cell.Width - pX;
				d.y = -pY;
				d.z = 0f;

				// Rotation
				if (cell.Rotation != 0) {
					var rot = Quaternion.Euler(0, 0, -cell.Rotation);
					a = rot * a;
					b = rot * b;
					c = rot * c;
					d = rot * d;
				}

				a.x += cell.X - ViewRect.x;
				a.y += cell.Y - ViewRect.y;
				b.x += cell.X - ViewRect.x;
				b.y += cell.Y - ViewRect.y;
				c.x += cell.X - ViewRect.x;
				c.y += cell.Y - ViewRect.y;
				d.x += cell.X - ViewRect.x;
				d.y += cell.Y - ViewRect.y;

				// Final
				GL.TexCoord2(uv.xMin, uv.yMin);
				GL.Vertex(a);
				GL.TexCoord2(uv.xMin, uv.yMax);
				GL.Vertex(b);
				GL.TexCoord2(uv.xMax, uv.yMax);
				GL.Vertex(c);
				GL.TexCoord2(uv.xMax, uv.yMin);
				GL.Vertex(d);
			}
			GL.End();
		}


		#endregion




		#region --- API ---


		// Layer
		public static void Init (int layerCount) {
			Layers = new Layer[layerCount];
			SheetIDMap.Clear();
		}


		public static void SetupLayer (int layerIndex, int cellCapaticy, Material material, Sprite[] sprites, Rect[] uvs) {
			var cells = new Cell[cellCapaticy];
			for (int i = 0; i < cellCapaticy; i++) {
				cells[i] = new Cell() { ID = -1 };
			}
			Layers[layerIndex] = FocusedLayer = new Layer() {
				Cells = cells,
				Material = material,
				UVs = uvs,
				UVCount = uvs.Length,
				CellCount = cellCapaticy,
			};
			FocusedLayerIndex = layerIndex;
			for (int i = 0; i < sprites.Length; i++) {
				Sprite sp = sprites[i];
				int id = sp.name.GetAngeliaHashCode();
				if (!SheetIDMap.ContainsKey(id)) {
					SheetIDMap.Add(id, (layerIndex, i));
				}
#if UNITY_EDITOR
				else {
					Debug.LogError($"[Cell Renderer] Sprite {sp}'s id already exists.");
				}
#endif
			}
		}


		// Draw
		public static void BeginDraw () {
			for (int i = 0; i < Layers.Length; i++) {
				Layers[i].FocusedCell = 0;
			}
		}


		public static void Draw (int globalID, int x, int y, int pivotX, int pivotY, int rotation, int width, int height, Color32 color) {
			if (!SheetIDMap.ContainsKey(globalID)) { return; }
			int sheet = SheetIDMap[globalID].sheet;
			if (sheet != FocusedLayerIndex) {
				FocusedLayerIndex = sheet;
				FocusedLayer = Layers[sheet];
			}
			int id = SheetIDMap[globalID].id;
			if (id >= FocusedLayer.UVCount || FocusedLayer.FocusedCell < 0) { return; }
			var cell = new Cell {
				ID = id,
				X = x,
				Y = y,
				Width = width,
				Height = height,
				Rotation = rotation,
				PivotX = pivotX,
				PivotY = pivotY,
				Color = color
			};
			FocusedLayer.Cells[FocusedLayer.FocusedCell] = cell;
			FocusedLayer.FocusedCell++;
			if (FocusedLayer.FocusedCell >= FocusedLayer.CellCount) {
				FocusedLayer.FocusedCell = -1;
			}
		}


		#endregion




	}
}
